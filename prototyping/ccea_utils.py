"""
These are the utils for the 2 rovers, 2 uavs experiments
"""
from librovers import rovers
from custom_env import createEnv
from copy import deepcopy
import numpy as np
import random

# Create a multi-rover evaluation
# This rover evaluation will have UAVs and rovers. And only rovers can capture POIs
def evaluate(team, num_steps, rover_network, uav_network, compute_team_fitness=False, include_uavs=True, reward_types=["Global", "Global", "Global", "Global"]):
    """Load in the rovers and evaluate them

    team: list of individuals (each individual is a list of weights)
    First two individuals are rovers. Next two are uavs
    compute_team_fitness: Perform an additional call to G and append it to the rewards
    """
    NUM_ROVERS = 2
    if include_uavs:
        NUM_UAVS = 2
    else:
        NUM_UAVS = 0

    # Let's do 2 rovers and 2 UAVs
    # Create a neural network for each rover
    rover_nns = [deepcopy(rover_network) for _ in range(NUM_ROVERS)]
    # And each uav
    uav_nns = [deepcopy(uav_network) for _ in range(NUM_UAVS)]

    # Load the weights for each rover (individual) into that rover's neural network
    for rover_nn, individual in zip(rover_nns, team[:NUM_ROVERS]):
        rover_nn.setWeights(individual)
    # And for uav networks
    for uav_nn, individual in zip(uav_nns, team[NUM_ROVERS:]):
        uav_nn.setWeights(individual)
    # Put em all together
    agent_nns = rover_nns + uav_nns

    # Set up the environment
    env = createEnv(include_uavs=include_uavs, reward_types=reward_types)

    states, _ = env.reset()

    for _ in range(num_steps):
        # Compute the actions of all the rovers (in this case just one rover)
        states_arrs = []
        actions_arrs = []
        actions = []
        for state, agent_nn in zip(states, agent_nns):
            slist = str(state.transpose()).split(" ")
            flist = list(filter(None, slist))
            nlist = [float(s) for s in flist]
            state_arr = np.array(nlist, dtype=np.float64)
            action_arr = agent_nn.forward(state_arr)
            # Save this info for debugging purposes
            states_arrs.append(state_arr)
            actions_arrs.append(action_arr)

        for action_arr in actions_arrs:
            action = rovers.tensor(action_arr)
            actions.append(action)

        states, rewards = env.step(actions)

    if compute_team_fitness:
        # Create an agent pack to pass to reward function
        agent_pack = rovers.AgentPack(
            agent_index = 0,
            agents = env.rovers(),
            entities = env.pois()
        )
        team_fitness = rovers.rewards.Global().compute(agent_pack)
        return tuple([(r,) for r in rewards]+[(team_fitness,)])

    else:
        # Each index corresponds to an agent's rewards
        # We only evaulate the team fitness based on the last step
        # so we only keep the last set of rewards generated by the team
        return tuple([(r,) for r in rewards])

def formChampionTeam(population):
    champion_team = []
    for subpop in population:
        # Use max with a key function to get the individual with the highest fitness[0] value
        best_ind = max(subpop, key=lambda ind: ind.fitness.values[0])
        champion_team.append(best_ind)
    return champion_team

def shuffle(population):
    for subpop in population:
        random.shuffle(subpop)

def formTeams(population, inds=None):
    # Start a list of teams
    teams = []

    if inds is None:
        SUBPOPULATION_SIZE = len(population[0])
        team_inds = range(SUBPOPULATION_SIZE)
    else:
        team_inds = inds

    # For each individual in a subpopulation
    for i in team_inds:
        # Make a team
        team = []
        # For each subpopulation in the population
        for subpop in population:
            # Put the i'th indiviudal on the team
            team.append(subpop[i])
        # Save that team
        teams.append(team)

    return teams

def formHOFTeams(population, hall_of_fame_team):
    """Every single individual is substituted into the hall of fame team
    So if there are S subpopulations and I individuals in each subpopulation
    This will form S*I teams
    """
    teams = []
    for index, subpop in enumerate(population):
        for individual in subpop:
            # Make a copy of the hall of fame team
            team = deepcopy(hall_of_fame_team)
            # Now substitue this individual for the associated
            # individual in the hall of fame team
            team[index] = individual
            teams.append(team)
    return teams
