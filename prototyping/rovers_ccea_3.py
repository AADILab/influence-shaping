"""
The rovers are learning now and I think it's time to experiment with different types of agents.

More specifically, I want to have a rover-type with a small observation radius that is capable of observing POIs
to get a higher team reward. And then a UAV type that has a large observation radius, but cannot "observe" POIs
in service of the team reward

Maybe rather than "observe" POIs, the agents are "capturing" POIs. Both agents can see the POIs, but only one
has the capability to capture POIs

Also trying out parallelization. Why not.
"""

from deap import base
from deap import creator
from deap import tools
import random
from typing import Union, List
import numpy as np
import multiprocessing
import os
# from scoop import futures

from tqdm import tqdm

from librovers import rovers, thyme
import cppyy

from copy import deepcopy, copy

from custom_env import createEnv

# Create a multi-rover evaluation
# This rover evaluation will have UAVs and rovers. And only rovers can capture POIs
def evaluate(team, num_steps, rover_network, uav_network, compute_team_fitness=False):
    """Load in the rovers and evaluate them

    team: list of individuals (each individual is a list of weights)
    First two individuals are rovers. Next two are uavs
    compute_team_fitness: Perform an additional call to G and append it to the rewards
    """
    # Let's do 2 rovers and 2 UAVs
    # Create a neural network for each rover
    rover_nns = [deepcopy(rover_network) for _ in range(NUM_ROVERS)]
    # And each uav
    uav_nns = [deepcopy(uav_network) for _ in range(NUM_UAVS)]

    # Load the weights for each rover (individual) into that rover's neural network
    for rover_nn, individual in zip(rover_nns, team[:NUM_ROVERS]):
        rover_nn.setWeights(individual)
    # And for uav networks
    for uav_nn, individual in zip(uav_nns, team[NUM_ROVERS:]):
        uav_nn.setWeights(individual)
    # Put em all together
    agent_nns = rover_nns + uav_nns

    # Set up the environment
    env = createEnv()

    states, _ = env.reset()

    for _ in range(num_steps):
        # Compute the actions of all the rovers (in this case just one rover)
        states_arrs = []
        actions_arrs = []
        actions = []
        for state, agent_nn in zip(states, agent_nns):
            slist = str(state.transpose()).split(" ")
            flist = list(filter(None, slist))
            nlist = [float(s) for s in flist]
            state_arr = np.array(nlist, dtype=np.float64)
            action_arr = agent_nn.forward(state_arr)
            # Save this info for debugging purposes
            states_arrs.append(state_arr)
            actions_arrs.append(action_arr)

        for action_arr in actions_arrs:
            action = rovers.tensor(action_arr)
            actions.append(action)

        states, rewards = env.step(actions)

    if compute_team_fitness:
        # Create an agent pack to pass to reward function
        agent_pack = rovers.AgentPack(
            agent_index = 0,
            agents = env.rovers(),
            entities = env.pois()
        )
        team_fitness = rovers.rewards.Global().compute(agent_pack)
        return tuple([(r,) for r in rewards]+[(team_fitness,)])

    else:
        # Each index corresponds to an agent's rewards
        # We only evaulate the team fitness based on the last step
        # so we only keep the last set of rewards generated by the team
        return tuple([(r,) for r in rewards])

def formChampionTeam(population):
    champion_team = []
    for subpop in population:
        # Use max with a key function to get the individual with the highest fitness[0] value
        best_ind = max(subpop, key=lambda ind: ind.fitness.values[0])
        champion_team.append(best_ind)
    return champion_team

def evaluateBestTeam(population, num_steps, rover_network, uav_network):
    """
    Create a champion team that is the best individual from each subpopulation
    Then evaluate that team
    Save the individual rewards (fitness) for each agent
    Then compute a G for the team's performance (team fitness)
    """
    # Create champion team
    champion_team = formChampionTeam(population)
    # Evaluate that team and get the agent fitnesses AND a team fitness
    fitnesses = evaluate(champion_team, num_steps, rover_network, uav_network, compute_team_fitness=True)

    return fitnesses

if __name__ == "__main__":
    # Neural network class for evaluation
    class NeuralNetwork:
        def __init__(self, num_inputs: int, num_hidden: Union[int, List[int]], num_outputs: int) -> None:
            if type(num_hidden) == int:
                num_hidden = [num_hidden]
            self.num_inputs, self.num_hidden, self.num_outputs = num_inputs, num_hidden, num_outputs
            # Number of nodes in each layer
            self.shape = tuple([self.num_inputs] + self.num_hidden + [self.num_outputs])
            # Number of layers
            self.num_layers = len(self.shape) - 1
            # Initialize weights with zeros
            self.weights = self.initWeights()
            # Store shape and size for later
            self.num_weights = self.calculateNumWeights()

        def shape(self):
            return (self.num_inputs, self.num_hidden, self.num_outputs)

        def initWeights(self) -> List[np.ndarray]:
            """Creates the numpy arrays for holding weights. Initialized to zeros """
            weights = []
            for num_inputs, num_outputs in zip(self.shape[:-1], self.shape[1:]):
                weights.append(np.zeros(shape=(num_inputs+1, num_outputs)))
            return weights

        def forward(self, X: np.ndarray) -> np.ndarray:
            # Input layer is not activated.
            # We treat it as an activated layer so that we don't activate it.
            # (you wouldn't activate an already activated layer)
            a = X
            # Feed forward through each layer of hidden units and the last layer of output units
            for layer_ind in range(self.num_layers):
                # Add bias term
                b = np.hstack((a, [1]))
                # Feedforward through the weights w. summations
                f = b.dot(self.weights[layer_ind])
                # Activate the summations
                a = self.activation(f)
            return a

        def setWeights(self, list_of_weights: List[float])->None:
            """Take a list of weights and set the
            neural network weights according to these weights"""
            # Check the size
            if len(list_of_weights) != self.num_weights:
                raise Exception("Weights are being set incorrectly in setWeights().\n"\
                                "The number of weights in the list is not the same as\n"\
                                "the number of weights in the network\n"\
                                +str(len(list_of_weights))+"!="+str(self.num_weights))
            list_ind = 0
            for layer in self.weights:
                for row in layer:
                    for element_ind in range(row.size):
                        row[element_ind] = list_of_weights[list_ind]
                        list_ind+=1

        def getWeights(self) -> List[float]:
            """Get the weights as a list"""
            weight_list = []
            for layer in self.weights:
                for row in layer:
                    for element in row:
                        weight_list.append(element)
            return weight_list

        def activation(self, arr: np.ndarray) -> np.ndarray:
            return np.tanh(arr)

        def calculateNumWeights(self) -> int:
            return sum([w.size for w in self.weights])

    # Let's save data
    save_dir = os.path.expanduser("~")+"/hpc-share/influence/preliminary/2_rovers_2_uavs_G/trial_0"
    if not os.path.isdir(save_dir):
        os.makedirs(save_dir)

    # We need a rover network and a uav network to get our sizing figured out
    rover_nn = NeuralNetwork(num_inputs=4*3, num_hidden=[10], num_outputs=2)
    ROVER_IND_SIZE = rover_nn.num_weights

    uav_nn = NeuralNetwork(num_inputs=12*3, num_hidden=[10], num_outputs=2)
    UAV_IND_SIZE = uav_nn.num_weights

    SUBPOPULATION_SIZE=50
    NUM_ROVERS=2
    NUM_UAVS=2
    NUM_AGENTS=NUM_ROVERS+NUM_UAVS
    NUM_STEPS=30

    # Create csv files for saving data
    top_line = "generation, team_fitness"
    for i in range(NUM_ROVERS):
        top_line += ", rover_"+str(i)
    for i in range(NUM_UAVS):
        top_line += ", uav_"+str(i)
    with open(save_dir+"/fitness.csv", 'w') as file:
        file.write(top_line)
        file.write('\n')

    creator.create("FitnessMax", base.Fitness, weights=(1.0,))
    creator.create("Individual", list, fitness=creator.FitnessMax)

    toolbox = base.Toolbox()
    pool = multiprocessing.Pool(processes=20)
    toolbox.register("map", pool.map_async)
    toolbox.register("attr_float", random.uniform, -0.5, 0.5)
    # rover or uav individual
    toolbox.register("rover_individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=ROVER_IND_SIZE)
    toolbox.register("uav_individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=UAV_IND_SIZE)
    # sub population of rovers or of uavs
    toolbox.register("rover_subpopulation", tools.initRepeat, list, toolbox.rover_individual, n=SUBPOPULATION_SIZE)
    toolbox.register("uav_subpopulation", tools.initRepeat, list, toolbox.uav_individual, n=SUBPOPULATION_SIZE)
    # Custom population function to merge rovers and uavs together in the same overall population
    def population():
        return tools.initRepeat(list, toolbox.rover_subpopulation, n=NUM_ROVERS) + \
            tools.initRepeat(list, toolbox.uav_subpopulation, n=NUM_UAVS)
    # population is a "population" of populations. One for each agent that is co-evolving
    toolbox.register("population", population)


    # Register all of our operators for crossover, mutation, selection, evaluation, team formation
    toolbox.register("crossover", tools.cxTwoPoint)
    toolbox.register("mutate", tools.mutGaussian, mu=0, sigma=1, indpb=0.1)
    toolbox.register("selectSubPopulation", tools.selTournament, tournsize=3)
    toolbox.register("evaluate", evaluate, num_steps=NUM_STEPS, rover_network=rover_nn, uav_network=uav_nn)

    def select(population):
        # Offspring is a list of subpopulation
        offspring = []
        # For each subpopulation in the population
        for subpop in population:
            # Perform a selection on that subpopulation, and add it to the offspring population
            offspring.append(toolbox.selectSubPopulation(subpop, len(subpop)))
        return offspring

    toolbox.register("select", select)

    def shuffle(population):
        for subpop in population:
            random.shuffle(subpop)

    toolbox.register("shuffle", shuffle)

    def formTeams(population, inds=None):
        # Start a list of teams
        teams = []

        if inds is None:
            team_inds = range(SUBPOPULATION_SIZE)
        else:
            team_inds = inds

        # For each individual in a subpopulation
        for i in team_inds:
            # Make a team
            team = []
            # For each subpopulation in the population
            for subpop in population:
                # Put the i'th indiviudal on the team
                team.append(subpop[i])
            # Save that team
            teams.append(team)

        return teams

    toolbox.register("formTeams", formTeams)

    def main():
        # Create population, with subpopulation for each agentpack
        pop = toolbox.population()

        # Define variables for our overall EA
        CXPB = 0.5 # Cross over probability
        MUTPB = 0.2 # Mutation probability
        NGEN = 1000

        # Shuffle each subpopulation
        toolbox.shuffle(pop)

        # Form teams
        teams = toolbox.formTeams(pop)

        # Evaluate each team
        jobs = toolbox.map(toolbox.evaluate, teams)
        team_fitnesses = jobs.get()

        # Now we go back through each team and assign fitnesses to individuals on teams
        for team, fitnesses in zip(teams, team_fitnesses):
            for individual, fit in zip(team, fitnesses):
                individual.fitness.values = fit

        # Evaluate the champions and save the fitnesses
        fitnesses = evaluateBestTeam(pop, num_steps=NUM_STEPS, rover_network=rover_nn, uav_network=uav_nn)
        fit_list = ["0"] + [str(fitnesses[-1][0])] + [str(fit[0]) for fit in fitnesses[:-1]]
        with open(save_dir+"/fitness.csv", 'a') as file:
            fit_str = ','.join(fit_list)
            file.write(fit_str+'\n')

        # For each generation
        for gen in tqdm(range(NGEN)):
            # Perform a 3-agent tournament selection on each subpopulation
            offspring = toolbox.select(pop)

            # Shuffle the subpopulations
            toolbox.shuffle(pop)

            # Make deepcopies so we don't accidentally overwrite anything
            offspring = list(map(toolbox.clone, offspring))

            # Track which fitnesses are going to be invalid
            invalid_ind = []

            # Crossover
            for num_individual in range(int(SUBPOPULATION_SIZE/2)):
                if random.random() < CXPB:
                    invalid_ind.append(num_individual*2)
                    invalid_ind.append(num_individual*2+1)
                    for subpop in pop:
                        toolbox.crossover(subpop[num_individual*2], subpop[num_individual*2+1])
                        del subpop[num_individual*2].fitness.values
                        del subpop[num_individual*2+1].fitness.values

            # Mutation
            for num_individual in range(SUBPOPULATION_SIZE):
                if random.random() < MUTPB:
                    invalid_ind.append(num_individual)
                    for subpop in pop:
                        toolbox.mutate(subpop[num_individual])
                        del subpop[num_individual].fitness.values

            # Create teams of individuals with invalid fitnesses
            teams = formTeams(pop, inds=invalid_ind)

            # Evaluate each team
            jobs = toolbox.map(toolbox.evaluate, teams)
            team_fitnesses = jobs.get()

            # Now we go back through each team and assign fitnesses to individuals on teams
            for team, fitnesses in zip(teams, team_fitnesses):
                for individual, fit in zip(team, fitnesses):
                    individual.fitness.values = fit

            # Evaluate the champions and save the fitnesses
            fitnesses = evaluateBestTeam(pop, num_steps=NUM_STEPS, rover_network=rover_nn, uav_network=uav_nn)
            fit_list = [str(gen+1)] + [str(fitnesses[-1][0])] + [str(fit[0]) for fit in fitnesses[:-1]]
            with open(save_dir+"/fitness.csv", 'a') as file:
                fit_str = ','.join(fit_list)
                file.write(fit_str+'\n')

            # Now populate the population with the individuals from the offspring
            for subpop, subpop_offspring in zip(pop, offspring):
                subpop[:] = subpop_offspring

        return pop

    pop = main()
    for subpop in pop[0:5]:
        for ind in subpop:
            print(ind.fitness.values)
