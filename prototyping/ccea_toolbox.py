from deap import base
from deap import creator
from deap import tools
from tqdm import tqdm

import multiprocessing
import random

from evo_network import NeuralNetwork

"""
These are the utils for the 2 rovers, 2 uavs experiments
"""
from librovers import rovers
from custom_env import createEnv
from copy import deepcopy
import numpy as np
import random
import os
from pathlib import Path
import yaml
import pprint
from tqdm import tqdm

# Create a multi-rover evaluation
# This rover evaluation will have UAVs and rovers. And only rovers can capture POIs
def evaluate(team, rover_network, uav_network, compute_team_fitness, config):
    """Load in the rovers and evaluate them

    team: list of individuals (each individual is a list of weights)
    First two individuals are rovers. Next two are uavs
    compute_team_fitness: Perform an additional call to G and append it to the rewards
    """
    NUM_ROVERS = len(config["env"]["agents"]["rovers"])
    NUM_UAVS = len(config["env"]["agents"]["uavs"])

    # Let's do 2 rovers and 2 UAVs
    # Create a neural network for each rover
    rover_nns = [deepcopy(rover_network) for _ in range(NUM_ROVERS)]
    # And each uav
    uav_nns = [deepcopy(uav_network) for _ in range(NUM_UAVS)]

    # Load the weights for each rover (individual) into that rover's neural network
    for rover_nn, individual in zip(rover_nns, team[:NUM_ROVERS]):
        rover_nn.setWeights(individual)
    # And for uav networks
    for uav_nn, individual in zip(uav_nns, team[NUM_ROVERS:]):
        uav_nn.setWeights(individual)
    # Put em all together
    agent_nns = rover_nns + uav_nns

    # Set up the environment
    env = createEnv(config)

    states, _ = env.reset()

    for _ in range(config["ccea"]["num_steps"]):
        # Compute the actions of all the rovers (in this case just one rover)
        states_arrs = []
        actions_arrs = []
        actions = []
        for ind, (state, agent_nn) in enumerate(zip(states, agent_nns)):
            slist = str(state.transpose()).split(" ")
            flist = list(filter(None, slist))
            nlist = [float(s) for s in flist]
            state_arr = np.array(nlist, dtype=np.float64)
            action_arr = agent_nn.forward(state_arr)
            # Multiply by agent velocity
            if ind <= NUM_ROVERS:
                # This is a rover
                action_arr*=config["ccea"]["network"]["rover_max_velocity"]
            else:
                # This is a uav
                action_arr*=config["ccea"]["network"]["uav_max_velocity"]
            # Save this info for debugging purposes
            states_arrs.append(state_arr)
            actions_arrs.append(action_arr)

        for action_arr in actions_arrs:
            action = rovers.tensor(action_arr)
            actions.append(action)

        states, rewards = env.step(actions)

    if compute_team_fitness:
        # Create an agent pack to pass to reward function
        agent_pack = rovers.AgentPack(
            agent_index = 0,
            agents = env.rovers(),
            entities = env.pois()
        )
        team_fitness = rovers.rewards.Global().compute(agent_pack)
        return tuple([(r,) for r in rewards]+[(team_fitness,)])

    else:
        # Each index corresponds to an agent's rewards
        # We only evaulate the team fitness based on the last step
        # so we only keep the last set of rewards generated by the team
        return tuple([(r,) for r in rewards])

def formChampionTeam(population):
    champion_team = []
    for subpop in population:
        # Use max with a key function to get the individual with the highest fitness[0] value
        best_ind = max(subpop, key=lambda ind: ind.fitness.values[0])
        champion_team.append(best_ind)
    return champion_team

def shuffle(population):
    for subpop in population:
        random.shuffle(subpop)

def formTeams(population, inds=None):
    # Start a list of teams
    teams = []

    if inds is None:
        SUBPOPULATION_SIZE = len(population[0])
        team_inds = range(SUBPOPULATION_SIZE)
        # print("formTeams(), SUBPOPULATION_SIZE: ", SUBPOPULATION_SIZE)
    else:
        team_inds = inds

    # For each individual in a subpopulation
    for i in team_inds:
        # Make a team
        team = []
        # For each subpopulation in the population
        for subpop in population:
            # Put the i'th indiviudal on the team
            team.append(subpop[i])
        # Save that team
        teams.append(team)

    return teams

def formHOFTeams(population, hall_of_fame_team):
    """Every single individual is substituted into the hall of fame team
    So if there are S subpopulations and I individuals in each subpopulation
    This will form S*I teams
    """
    teams = []
    for index, subpop in enumerate(population):
        for individual in subpop:
            # Make a copy of the hall of fame team
            team = deepcopy(hall_of_fame_team)
            # Now substitue this individual for the associated
            # individual in the hall of fame team
            team[index] = individual
            teams.append(team)
    return teams

def setupToolbox(config):
    # Setup variables for convenience
    NUM_ROVERS = len(config["env"]["agents"]["rovers"])
    NUM_UAVS = len(config["env"]["agents"]["uavs"])
    SUBPOPULATION_SIZE = config["ccea"]["population"]["subpopulation_size"]
    NUM_HIDDEN = config["ccea"]["network"]["hidden_layers"]

    rover_nn = NeuralNetwork(num_inputs=4*3, num_hidden=NUM_HIDDEN, num_outputs=2)
    uav_nn = NeuralNetwork(num_inputs=12*3, num_hidden=NUM_HIDDEN, num_outputs=2)

    if NUM_ROVERS > 0:
        ROVER_RESOLUTION = config["env"]["agents"]["rovers"][0]["resolution"]
        ROVER_SECTORS = int(360/ROVER_RESOLUTION)
        rover_nn = NeuralNetwork(num_inputs=ROVER_SECTORS*3, num_hidden=NUM_HIDDEN, num_outputs=2)

    if NUM_UAVS > 0:
        UAV_RESOLUTION = config["env"]["agents"]["uavs"][0]["resolution"]
        UAV_SECTORS = int(360/UAV_RESOLUTION)
        uav_nn = NeuralNetwork(num_inputs=UAV_SECTORS*3, num_hidden=NUM_HIDDEN, num_outputs=2)

    ROVER_IND_SIZE = rover_nn.num_weights
    UAV_IND_SIZE = uav_nn.num_weights

    USE_MULTIPROCESSING = config["processing"]["use_multiprocessing"]
    NUM_THREADS = config["processing"]["num_threads"]

    # Create the type of fitness we're optimizing
    creator.create("FitnessMax", base.Fitness, weights=(1.0,))
    creator.create("Individual", list, fitness=creator.FitnessMax)

    # Now set up our evolutionary toolbox
    toolbox = base.Toolbox()
    if USE_MULTIPROCESSING:
        pool = multiprocessing.Pool(processes=NUM_THREADS)
        toolbox.register("map", pool.map_async)
    else:
        print("not multiprocessing")
        toolbox.register("map", map)
    toolbox.register("attr_float", random.uniform, config["ccea"]["weight_initialization"]["lower_bound"], config["ccea"]["weight_initialization"]["upper_bound"])
    # rover or uav individual
    toolbox.register("rover_individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=ROVER_IND_SIZE)
    toolbox.register("uav_individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=UAV_IND_SIZE)
    # sub population of rovers or of uavs
    toolbox.register("rover_subpopulation", tools.initRepeat, list, toolbox.rover_individual, n=SUBPOPULATION_SIZE)
    toolbox.register("uav_subpopulation", tools.initRepeat, list, toolbox.uav_individual, n=SUBPOPULATION_SIZE)
    # Custom population function to merge rovers and uavs together in the same overall population
    def population():
        return tools.initRepeat(list, toolbox.rover_subpopulation, n=NUM_ROVERS) + \
            tools.initRepeat(list, toolbox.uav_subpopulation, n=NUM_UAVS)
    # population is a "population" of populations. One for each agent that is co-evolving
    toolbox.register("population", population)

    # Register all of our operators for crossover, mutation, selection, evaluation, team formation
    toolbox.register("crossover", tools.cxTwoPoint)
    toolbox.register("mutate", tools.mutGaussian, mu=config["ccea"]["mutation"]["mean"], sigma=config["ccea"]["mutation"]["std_deviation"], indpb=config["ccea"]["mutation"]["independent_probability"])

    def selectNElitesBinaryTournament(population, N, include_elites_in_tournament):
        # Get the best N individuals
        offspring = tools.selBest(population, N)

        if include_elites_in_tournament:
            offspring += tools.selTournament(population, len(population)-N, tournsize=2)
            return offspring

        else:
            # Get the remaining worse individuals
            remaining_offspring = tools.selWorst(population, len(population)-N)

            # Add those remaining individuals through a binary tournament
            offspring += tools.selTournament(remaining_offspring, len(remaining_offspring), tournsize=2)

            return offspring

    toolbox.register("selectSubPopulation", selectNElitesBinaryTournament)
    toolbox.register("evaluate", evaluate, rover_network=rover_nn, uav_network=uav_nn, config=config)
    toolbox.register("evaluateWithTeamFitness", evaluate, rover_network=rover_nn, uav_network=uav_nn, compute_team_fitness=True, config=config)

    def select(population, N, include_elites_in_tournament):
        # Offspring is a list of subpopulation
        offspring = []
        # For each subpopulation in the population
        for subpop in population:
            # Perform a selection on that subpopulation, and add it to the offspring population
            offspring.append(toolbox.selectSubPopulation(subpop, N, include_elites_in_tournament))
        return offspring

    toolbox.register("select", select)
    toolbox.register("shuffle", shuffle)
    toolbox.register("formTeams", formTeams)
    toolbox.register("formHOFTeams", formHOFTeams)

    def evaluateBestTeam(population):
        """
        Create a champion team that is the best individual from each subpopulation
        Then evaluate that team
        Save the individual rewards (fitness) for each agent
        Then compute a G for the team's performance (team fitness)
        """
        # Create champion team
        champion_team = formChampionTeam(population)
        # Evaluate that team and get the agent fitnesses AND a team fitness
        fitnesses = toolbox.evaluate(champion_team, compute_team_fitness=True)

        return fitnesses

    toolbox.register("evaluateBestTeam", evaluateBestTeam)

    return toolbox

# This is the top level function that runs everything
def runCCEA(config_dir):
    config_dir = Path(os.path.expanduser(config_dir))

    trials_dir = config_dir.parent
    with open(str(config_dir), 'r') as file:
        config = yaml.safe_load(file)

    # Run for the specified number of trials
    for num_trial in range(config["experiment"]["num_trials"]):
        # Setup the directory for saving data
        trial_dir = trials_dir / ("trial_"+str(num_trial))
        if not os.path.isdir(trial_dir):
            os.makedirs(trial_dir)

        # Create csv file for saving data
        fitness_dir = trial_dir / "fitness.csv"
        top_line = "generation, team_fitness"
        for i in range(len(config["env"]["agents"]["rovers"])):
            top_line += ", rover_"+str(i)
        for i in range(len(config["env"]["agents"]["uavs"])):
            top_line += ", uav_"+str(i)
        for s in range(config["ccea"]["population"]["subpopulation_size"]):
            top_line += ", team_fitness_train_"+str(s)
        with open(fitness_dir, 'w') as file:
            file.write(top_line)
            file.write('\n')

        # Setup toolbox for evolution
        toolbox = setupToolbox(config)

        # Create population, with subpopulation for each agent
        pop = toolbox.population()

        # Form teams
        teams = toolbox.formTeams(pop)

        # Evaluate each team
        jobs = toolbox.map(toolbox.evaluateWithTeamFitness, teams)
        team_fitnesses = jobs.get()
        print("team_fitnesses:")
        print(team_fitnesses)

        # Save the Hall of Fame champion team
        # team_pairs = zip(teams, team_fitnesses)
        # hall_of_fame_team_pair = max(team_pairs, key=lambda team_pair: team_pair[1][-1][0])
        # hall_of_fame_team = hall_of_fame_team_pair[0]

        training_fitnesses = []
        ind = 0
        # Now we go back through each team and assign fitnesses to individuals on teams
        for team, fitnesses in zip(teams, team_fitnesses):
            # Save the team fitness from training
            training_fitnesses.append(fitnesses[-1][0])
            for individual, fit in zip(team, fitnesses):
                individual.fitness.values = fit
                ind += 1

        for subpopulation in pop:
            for count, individual in enumerate(subpopulation):
                print("fitness for "+str(count)+" : ", individual.fitness.values)

        # exit()
        # Evaluate the champions and save the fitnesses
        fitnesses = toolbox.evaluateBestTeam(pop)
        fit_list = ["0"] + [str(fitnesses[-1][0])] + \
            [str(fit[0]) for fit in fitnesses[:-1]] + \
            [str(fit) for fit in training_fitnesses]
        with open( str(fitness_dir) , 'a') as file:
            fit_str = ','.join(fit_list)
            file.write(fit_str+'\n')

        # For each generation
        for gen in tqdm(range(config["ccea"]["num_generations"])):
            # Perform a N-elites binary tournament selection on each subpopulation
            N_ELITES = config["ccea"]["selection"]["n_elites_binary_tournament"]["n_elites"]
            offspring = toolbox.select(
                pop,
                N=N_ELITES,
                include_elites_in_tournament=config["ccea"]["selection"]["n_elites_binary_tournament"]["include_elites_in_tournament"]
            )
            # When the selection operation selects individuals, it makes copies of them, so changing the weights of a copy of
            # an individual also changes the weights of the original individual. This couples individuals in a strange way
            # and causes issues with learning, so this line fixes that by ensuring each individual is a unique object and if you
            # change the weights for one individual, it will not affect the weights of the original individual
            offspring = [ [ deepcopy(individual) for individual in subpopulation ] for subpopulation in offspring ]
            print("Post Selection")
            for subpopulation in offspring:
                for count, individual in enumerate(subpopulation):
                    print("fitness for "+str(count)+" : ", individual.fitness.values)

            for subpopulation in offspring:
                for count, individual in enumerate(subpopulation):
                    print("Sum for indvidual "+str(count)+" : ", np.sum(individual))

            # Mutation
            SUBPOPULATION_SIZE = config["ccea"]["population"]["subpopulation_size"]
            num_mutants = SUBPOPULATION_SIZE-N_ELITES
            print("Number of mutants: ", num_mutants)
            for num_individual in range(num_mutants):
                print("Indivudal number: ", num_individual)
                mutant_id = num_individual+N_ELITES
                print("mutant_id: ", mutant_id)
                for subpop in offspring:
                    print("Pre mutation sum: ", np.sum(subpop[mutant_id]))
                    toolbox.mutate(subpop[mutant_id])
                    print("Post mutate sum: ", np.sum(subpop[mutant_id]))
                    del subpop[mutant_id].fitness.values

            print("Post Mutation")

            for subpopulation in offspring:
                for count, individual in enumerate(subpopulation):
                    print("Sum for indvidual "+str(count)+" : ", np.sum(individual))

            exit()

            # Shuffle subpopulations in the offspring
            toolbox.shuffle(offspring)

            # Form random teams of individuals
            random_teams = toolbox.formTeams(offspring)
            # print("random_teams: ", len(random_teams))

            # Now form teams using the hall of fame for each individual
            # hof_teams = toolbox.formHOFTeams(offspring, hall_of_fame_team)
            # print("hof_teams: ", len(hof_teams))

            # Aggregate all the teams
            # teams = random_teams + hof_teams
            teams = random_teams
            # print("teams: ", len(teams))
            # exit()

            # Evaluate each team
            jobs = toolbox.map(toolbox.evaluateWithTeamFitness, teams)
            team_fitnesses = jobs.get()

            # Now we go back through each team and assign fitnesses to individuals on teams
            # (This is just based on the fitnesses from the random teams)
            training_fitnesses = []
            # total_individuals = SUBPOPULATION_SIZE*len(offspring)
            num_inds_with_fitness = 0
            for team, fitnesses in zip(teams, team_fitnesses):
                # Save the team fitness from training
                training_fitnesses.append(fitnesses[-1][0])
                for individual, fit in zip(team, fitnesses):
                    individual.fitness.values = fit
                    num_inds_with_fitness += 1
            # print("assigned fitness: ", num_inds_with_fitness)

            # exit()

            # Now we are going to add the hall of fame values
            # ALPHA = config["ccea"]["evaluation"]["hall_of_fame"]["alpha"]
            # individual_index = 0
            # for subpop in offspring:
            #     for individual in subpop:
            #         # print("SUBPOPULATION_SIZE: ", SUBPOPULATION_SIZE)
            #         # print("individual.fitness.values: ", individual.fitness.values)
            #         # print("len(teams): ", len(teams))
            #         # print("SUBPOPULATION_SIZE+individual_index: ", SUBPOPULATION_SIZE+individual_index)
            #         # print('individual_index: ', individual_index)
            #         individual.fitness.values = \
            #             (individual.fitness.values[0]*ALPHA + (1-ALPHA)*team_fitnesses[SUBPOPULATION_SIZE+individual_index][-1][0],)
            #         individual_index+=1

            # And now we check if there is a new hall of fame team
            # team_pairs = zip(teams, team_fitnesses)
            # new_hall_of_fame_team_pair = max(team_pairs, key=lambda team_pair: team_pair[1][-1][0])
            # if new_hall_of_fame_team_pair[1][-1][0] > hall_of_fame_team_pair[1][-1][0]:
            #     hall_of_fame_team_pair = new_hall_of_fame_team_pair
            #     hall_of_fame_team = new_hall_of_fame_team_pair[0]

            # Save the fitnesses of the HOF team
            # fitnesses = hall_of_fame_team_pair[1]
            fitnesses = toolbox.evaluateBestTeam(offspring)
            fit_list = [str(gen+1)] + [str(fitnesses[-1][0])] + \
                [str(fit[0]) for fit in fitnesses[:-1]] + \
                [str(fit) for fit in training_fitnesses]
            with open(str(fitness_dir), 'a') as file:
                fit_str = ','.join(fit_list)
                file.write(fit_str+'\n')

            # Now populate the population with the individuals from the offspring
            for subpop, subpop_offspring in zip(pop, offspring):
                subpop[:] = subpop_offspring
    return pop
