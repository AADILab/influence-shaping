from deap import base
from deap import creator
from deap import tools

import multiprocessing
import random

from evo_network import NeuralNetwork

"""
These are the utils for the 2 rovers, 2 uavs experiments
"""
from librovers import rovers
from custom_env import createEnv
from copy import deepcopy
import numpy as np
import random

# Create a multi-rover evaluation
# This rover evaluation will have UAVs and rovers. And only rovers can capture POIs
def evaluate(team, rover_network, uav_network, compute_team_fitness, config):
    """Load in the rovers and evaluate them

    team: list of individuals (each individual is a list of weights)
    First two individuals are rovers. Next two are uavs
    compute_team_fitness: Perform an additional call to G and append it to the rewards
    """
    NUM_ROVERS = len(config["env"]["agents"]["rovers"])
    NUM_UAVS = len(config["env"]["agents"]["uavs"])

    # Let's do 2 rovers and 2 UAVs
    # Create a neural network for each rover
    rover_nns = [deepcopy(rover_network) for _ in range(NUM_ROVERS)]
    # And each uav
    uav_nns = [deepcopy(uav_network) for _ in range(NUM_UAVS)]

    # Load the weights for each rover (individual) into that rover's neural network
    for rover_nn, individual in zip(rover_nns, team[:NUM_ROVERS]):
        rover_nn.setWeights(individual)
    # And for uav networks
    for uav_nn, individual in zip(uav_nns, team[NUM_ROVERS:]):
        uav_nn.setWeights(individual)
    # Put em all together
    agent_nns = rover_nns + uav_nns

    # Set up the environment
    env = createEnv(config)

    states, _ = env.reset()

    for _ in range(config["ccea"]["num_steps"]):
        # Compute the actions of all the rovers (in this case just one rover)
        states_arrs = []
        actions_arrs = []
        actions = []
        for ind, (state, agent_nn) in enumerate(zip(states, agent_nns)):
            slist = str(state.transpose()).split(" ")
            flist = list(filter(None, slist))
            nlist = [float(s) for s in flist]
            state_arr = np.array(nlist, dtype=np.float64)
            action_arr = agent_nn.forward(state_arr)
            # Multiply by agent velocity
            if ind <= NUM_ROVERS:
                # This is a rover
                action_arr*=config["ccea"]["network"]["rover_max_velocity"]
            else:
                # This is a uav
                action_arr*=config["ccea"]["network"]["uav_max_velocity"]
            # Save this info for debugging purposes
            states_arrs.append(state_arr)
            actions_arrs.append(action_arr)

        for action_arr in actions_arrs:
            action = rovers.tensor(action_arr)
            actions.append(action)

        states, rewards = env.step(actions)

    if compute_team_fitness:
        # Create an agent pack to pass to reward function
        agent_pack = rovers.AgentPack(
            agent_index = 0,
            agents = env.rovers(),
            entities = env.pois()
        )
        team_fitness = rovers.rewards.Global().compute(agent_pack)
        return tuple([(r,) for r in rewards]+[(team_fitness,)])

    else:
        # Each index corresponds to an agent's rewards
        # We only evaulate the team fitness based on the last step
        # so we only keep the last set of rewards generated by the team
        return tuple([(r,) for r in rewards])

def formChampionTeam(population):
    champion_team = []
    for subpop in population:
        # Use max with a key function to get the individual with the highest fitness[0] value
        best_ind = max(subpop, key=lambda ind: ind.fitness.values[0])
        champion_team.append(best_ind)
    return champion_team

def shuffle(population):
    for subpop in population:
        random.shuffle(subpop)

def formTeams(population, inds=None):
    # Start a list of teams
    teams = []

    if inds is None:
        SUBPOPULATION_SIZE = len(population[0])
        team_inds = range(SUBPOPULATION_SIZE)
        # print("formTeams(), SUBPOPULATION_SIZE: ", SUBPOPULATION_SIZE)
    else:
        team_inds = inds

    # For each individual in a subpopulation
    for i in team_inds:
        # Make a team
        team = []
        # For each subpopulation in the population
        for subpop in population:
            # Put the i'th indiviudal on the team
            team.append(subpop[i])
        # Save that team
        teams.append(team)

    return teams

def formHOFTeams(population, hall_of_fame_team):
    """Every single individual is substituted into the hall of fame team
    So if there are S subpopulations and I individuals in each subpopulation
    This will form S*I teams
    """
    teams = []
    for index, subpop in enumerate(population):
        for individual in subpop:
            # Make a copy of the hall of fame team
            team = deepcopy(hall_of_fame_team)
            # Now substitue this individual for the associated
            # individual in the hall of fame team
            team[index] = individual
            teams.append(team)
    return teams

def setupToolbox(config):
    # Setup variables for convenience
    NUM_ROVERS = len(config["env"]["agents"]["rovers"])
    NUM_UAVS = len(config["env"]["agents"]["uavs"])
    SUBPOPULATION_SIZE = config["ccea"]["population"]["subpopulation_size"]
    NUM_HIDDEN = config["ccea"]["network"]["hidden_layers"]

    rover_nn = NeuralNetwork(num_inputs=4*3, num_hidden=NUM_HIDDEN, num_outputs=2)
    uav_nn = NeuralNetwork(num_inputs=12*3, num_hidden=NUM_HIDDEN, num_outputs=2)
    ROVER_IND_SIZE = rover_nn.num_weights
    UAV_IND_SIZE = uav_nn.num_weights
    NUM_STEPS = config["ccea"]["num_steps"]

    USE_MULTIPROCESSING = config["processing"]["use_multiprocessing"]
    NUM_THREADS = config["processing"]["num_threads"]

    # Create the type of fitness we're optimizing
    creator.create("FitnessMax", base.Fitness, weights=(1.0,))
    creator.create("Individual", list, fitness=creator.FitnessMax)

    # Now set up our evolutionary toolbox
    toolbox = base.Toolbox()
    if USE_MULTIPROCESSING:
        pool = multiprocessing.Pool(processes=NUM_THREADS)
        toolbox.register("map", pool.map_async)
    else:
        print("not multiprocessing")
        toolbox.register("map", map)
    toolbox.register("attr_float", random.uniform, config["ccea"]["weight_initialization"]["lower_bound"], config["ccea"]["weight_initialization"]["upper_bound"])
    # rover or uav individual
    toolbox.register("rover_individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=ROVER_IND_SIZE)
    toolbox.register("uav_individual", tools.initRepeat, creator.Individual, toolbox.attr_float, n=UAV_IND_SIZE)
    # sub population of rovers or of uavs
    toolbox.register("rover_subpopulation", tools.initRepeat, list, toolbox.rover_individual, n=SUBPOPULATION_SIZE)
    toolbox.register("uav_subpopulation", tools.initRepeat, list, toolbox.uav_individual, n=SUBPOPULATION_SIZE)
    # Custom population function to merge rovers and uavs together in the same overall population
    def population():
        return tools.initRepeat(list, toolbox.rover_subpopulation, n=NUM_ROVERS) + \
            tools.initRepeat(list, toolbox.uav_subpopulation, n=NUM_UAVS)
    # population is a "population" of populations. One for each agent that is co-evolving
    toolbox.register("population", population)

    # Register all of our operators for crossover, mutation, selection, evaluation, team formation
    toolbox.register("crossover", tools.cxTwoPoint)
    toolbox.register("mutate", tools.mutGaussian, mu=config["ccea"]["mutation"]["mean"], sigma=config["ccea"]["mutation"]["std_deviation"], indpb=config["ccea"]["mutation"]["independent_probability"])

    def selectNElitesBinaryTournament(population, N):
        # Get the best N individuals
        offspring = tools.selBest(population, N)

        # Get the remaining worse individuals
        remaining_offspring = tools.selWorst(population, len(population)-N)

        # Add those remaining individuals through a binary tournament
        offspring += tools.selTournament(remaining_offspring, len(remaining_offspring), tournsize=2)

        return offspring

    toolbox.register("selectSubPopulation", selectNElitesBinaryTournament)
    toolbox.register("evaluate", evaluate, rover_network=rover_nn, uav_network=uav_nn, config=config)
    toolbox.register("evaluateWithTeamFitness", evaluate, rover_network=rover_nn, uav_network=uav_nn, compute_team_fitness=True, config=config)

    def select(population, N):
        # Offspring is a list of subpopulation
        offspring = []
        # For each subpopulation in the population
        for subpop in population:
            # Perform a selection on that subpopulation, and add it to the offspring population
            offspring.append(toolbox.selectSubPopulation(subpop, N))
        return offspring

    toolbox.register("select", select)
    toolbox.register("shuffle", shuffle)
    toolbox.register("formTeams", formTeams)
    toolbox.register("formHOFTeams", formHOFTeams)

    def evaluateBestTeam(population):
        """
        Create a champion team that is the best individual from each subpopulation
        Then evaluate that team
        Save the individual rewards (fitness) for each agent
        Then compute a G for the team's performance (team fitness)
        """
        # Create champion team
        champion_team = formChampionTeam(population)
        # Evaluate that team and get the agent fitnesses AND a team fitness
        fitnesses = toolbox.evaluate(champion_team, compute_team_fitness=True)

        return fitnesses

    toolbox.register("evaluateBestTeam", evaluateBestTeam)

    return toolbox
